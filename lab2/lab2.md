### 练习

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

#### 练习0：填写已有实验

本实验依赖实验1。请把你做的实验1的代码填入本实验中代码中有“LAB1”的注释相应部分并按照实验手册进行进一步的修改。具体来说，就是跟着实验手册的教程一步步做，然后完成教程后继续完成完成exercise部分的剩余练习。

#### 练习1：理解first-fit 连续物理内存分配算法（思考题）
first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
- 你的first fit算法是否有进一步的改进空间？

各个函数的作用：
- default_init()函数：初始化空闲块链表 `free_list` 以及空闲页面数量 `nr_free`。
- default_init_memmap()函数：初始化物理内存区域，并将空闲页面插入到空闲块链表中。
	- 循环遍历页面，清空 `flags` 和 `property`字段，确保这些页不再被标记为保留状态，并将页面引用计数设为0。
	- 将起始页的 `property` 设置为 `n`，表示这是一个大小为 `n` 页的连续空闲块。调用 `SetPageProperty` 来标记该页为“属性页”，表示这是一个空闲块的起始页。更新全局的空闲页计数 `nr_free`。
	- 将空闲块添加到空闲块链表中，并更新 `nr_free` 计数。
- default_alloc_pages()函数：分配连续的物理页。
	- 遍历空闲块链表，查找第一个块大小大于等于 `n`的块。
	- 找到一个足够大的块后，进行内存分配，然后从链表中移除该块。
	- 如果找到的块比所需的块大，剩下的部分重新添加回空闲块链表作为一个新的块。
	- 从总空闲页数 `nr_free` 中减去分配的页数 `n`，调用 `ClearPageProperty(page)` 表示该块已经分配，不再是空闲块。
- default_free_pages()函数：将已分配的物理页重新释放回空闲块链表，并在可能的情况下将相邻的空闲内存块进行合并。
	- 循环遍历每一个待释放的页，使用断言确保这些页既不是保留页（`PageReserved`），也不是已经标记为空闲的页（`PageProperty`），清空 `flags` 字段，并将页面引用计数设为0，表示该页已不再被使用。
	- 将起始页的 `property` 设置为 `n`，表示这是一个大小为 `n` 页的连续空闲块。调用 `SetPageProperty` 来标记该页为“属性页”，表示这是一个空闲块的起始页。更新全局的空闲页计数 `nr_free`。
	- 将空闲块添加到空闲块链表中，并更新 `nr_free` 计数。
	- 查找该空闲块前面的和后面的空闲块，如果成功就进行合并，通过增加 `property` 来扩展块的大小，并从链表中删除原空闲块。

改进空间：
- 当前的链表插入是顺序遍历链表寻找合适的位置，如果链表很长，性能会下降。可以考虑使用更高效的数据结构，比如跳表或红黑树。
- 如果空闲块被频繁分割，可能导致内存碎片化。可以进一步优化合并策略或者引入更复杂的分配算法（如Best-Fit）。

#### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？

设计实现过程：在分配物理页时，遍历空闲块链表，找到比所需页数大的空闲块，如果当前还没有找到合适的空闲块，直接把当前的空闲块分配给`page`，如果找到更小的空闲块，就将`page`更新为更小的空闲块。

和 first-fit 算法的主要区别是增加了`if(page == NULL || page->property > p->property)`
```
while ((le = list_next(le)) != &free_list) {
        struct Page *p = le2page(le, page_link);
        if (p->property >= n) {
            if(page == NULL || page->property > p->property)
                page = p;
        }
    }
```
改进空间：
- 当前的链表插入是顺序遍历链表寻找合适的位置，如果链表很长，性能会下降。可以考虑使用更高效的数据结构，比如跳表或红黑树。

#### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。
 
#### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？


> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。