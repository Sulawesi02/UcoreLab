## lab0.5
#### 练习1：使用GDB验证启动流程
为了熟悉使用qemu和gdb进行调试工作,使用gdb调试QEMU模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令（即跳转到`0x80200000`）这个阶段的执行过程，说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？

答：RISC-V 硬件加电后的初始指令从复位地址 `0x1000` 开始。
```
0x1000: auipc	t0,0x0 # 将20位的立即数0x0符号扩展为32位，然后将其加到PC的高20位中，生成一个32位的地址，结果存储到寄存器 t0 中
0x1004:	addi	a1,t0,32 # 将寄存器 t0 的值加上立即数32，结果存储在寄存器 a1 中
0x1008:	csrr	a0,mhartid # 将控制和状态寄存器 mhartid 的值读取并保存当前处理器的 ID 到寄存器 a0 中
0x100c:	ld	t0,24(t0) # 从内存地址 t0 + 24 处加载一个64位的值到寄存器 t0 中，那个地址保存的值就是0x80000000
0x1010:	jr	t0 # 无条件跳转到寄存器 t0 中存储的地址
```
PC 被设置为复位地址 `0x1000`，开始执行复位代码。复位代码执行完成后，将 PC 设置为固件的加载地址 `0x80000000`，开始执行固件代码，并且将操作系统内核加载到内存中的预定位置 `0x80200000`。固件代码执行完成后，将 PC 设置为 `0x80200000`，跳转到操作系统内核的入口点，开始执行内核代码。

## lab1
#### 练习1：理解内核启动中的程序入口操作
阅读 `kern/init/entry.S`内容代码，结合操作系统内核启动流程，说明指令 `la sp, bootstacktop` 完成了什么操作，目的是什么？`tail kern_init` 完成了什么操作，目的是什么？

答：`la sp, bootstacktop`将标签 `bootstacktop` 的地址加载到寄存器 `sp` 中，目的是初始化栈指针寄存器`sp` 为指向内核启动栈的顶部。
`tail kern_init`跳转到 `kern_init` 函数，目的是传递控制权给 `kern_init`，开始执行内核代码。
#### 练习2：完善中断处理 （需要编程）
请编程完善`trap.c`中的中断处理函数`trap`，在对时钟中断进行处理的部分填写`kern/trap/trap.c`函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用`print_ticks`子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用`sbi.h`中的`shut_down()`函数关机。

要求完成问题1提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程和定时器中断中断处理的流程。实现要求的部分代码后，运行整个系统，大约每1秒会输出一次”100 ticks”，输出10行。

答：在`kern/driver/clock.c`中，`clock_init`使能时钟中断，并设置第一个时钟中断事件，初始化一个定时器。当定时器到达时间时，会触发一次时钟中断，处理器接收到信号后，会执行中断服务程序（ISR），根据 `stvec` 寄存器中的设置跳转到中断处理程序的入口点，即`kern/trap/trapentry.S`的 `__alltraps`。`__alltraps` 调用 `SAVE_ALL` 来保存上下文，然后跳转到 `trap` 函数。在 `kern/trap/trap.c` 中，`trap` 函数实际上把中断处理、异常处理的工作分发给了`interrupt_handler`、`exception_handler`，这些函数再根据中断或异常的不同类型来处理。对于时钟中断，`interrupt_handler`函数会设置下一次时钟中断事件，并累加计数器，进行相关处理。中断处理程序执行完毕后，`__trapret` 会调用 `RESTORE_ALL` 宏恢复保存的上下文，然后使用 `sret` 指令从中断中返回，恢复到中断发生前的执行状态。