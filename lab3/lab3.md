### 练习

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点
 
#### 练习0：填写已有实验
本实验依赖实验1/2。请把你做的实验1/2的代码填入本实验中代码中有“LAB1”,“LAB2”的注释相应部分。

#### 练习1：理解基于FIFO的页面替换算法（思考题）
描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？（为了方便同学们完成练习，所以实际上我们的项目代码和实验指导的还是略有不同，例如我们将FIFO页面置换算法头文件的大部分代码放在了`kern/mm/swap_fifo.c`文件中，这点请同学们注意）
 - 至少正确指出10个不同的函数分别做了什么？如果少于10个将酌情给分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响,删去后会导致输出结果不同的函数（例如assert）而不是cprintf这样的函数。如果你选择的函数不能完整地体现”从换入到换出“的过程，比如10个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这10个函数在页面换入时的功能，那么也会扣除一定的分数

1. `swap_in()`：将要换出的页面的数据从内存换出到磁盘交换区，将要换入的页面的数据从磁盘换入内存。
	2. `alloc_page()`宏：实际调用的是`alloc_pages(1)`函数，分配一页物理页面。在每次循环中，尝试调用`pmm_manager->alloc_pages(n)`分配物理页面，如果获取失败，则会调用`swap_out`函数换出页面。
		3. `swap_out()`：将要换出的页面的数据从内存换出到磁盘交换区。
			4. `sm->swap_out_victim()`：实际调用的是`_fifo_swap_out_victim`，选择要换出的页面。
				5. `_fifo_swap_out_victim()`：按照 FIFO 页面置换算法，从可交换页面链表`pra_list_head`中选择链表头部的前一个节点（即最早进入内存的页面所在节点）作为要换出的页面。
			6. `get_pte()`：寻找要换出的页面的虚拟地址对应的页表项。
			7. `swapfs_write()`：将要换出的页面的数据换出到磁盘交换区。
			8. `free_page()`：释放要换出的页面所占用的内存资源。
			9. `tlb_invalidate()`：由于在换出页面时修改了页表项，可能会导致转换后备缓冲区（TLB）中的缓存映射信息与要换入的页表不一致，所以需要调用`tlb_invalidate()`函数来刷新TLB，确保后续的内存访问能够根据要换入的页表映射正确进行。
	- `get_pte()`：创建要换入页面的虚拟地址对应的页表项。
	10. `swapfs_read()`：将要换入页面的数据从磁盘交换区读取到通过`alloc_page`分配好的物理页面中。
11. `page_insert()`：更新页表，插入要换入的页表项，建立物理地址与虚拟地址的映射。
	-  `get_pte()`：寻找要换入页面的虚拟地址对应的页表项。
	12. `page_ref_inc()`：增加要换入页面的引用计数。
	13. `page_ref_dec()`：如果已有页面与要换入的页面是同一个页面，说明该虚拟地址已经映射到了要换入的这个页面，调用`page_ref_dec`函数减少一次页面`page`的引用计数。
	14. `page_remove_pte()`：如果已有页面与要换入的页面不是同一个页面，说明存在页面映射冲突，此时调用`page_remove_pte`函数来移除原有的页表项，为要换入的页表项腾出空间
	15. `pte_create()`：根据要换入页面的物理页号以及设置的权限，创建一个要换入的页表项
	- `tlb_invalidate()`：由于修改了页表项，所以需要刷新TLB
16. `swap_map_swappable()`：会调用`sm->map_swappable`，实际调用的是`_fifo_map_swappable`，更新可交换页面链表。
	17. `_fifo_map_swappable`：按照 FIFO 页面置换算法，当有要换入的可交换页面进入内存时，将页面的链表节点插入到可交换页面链表`pra_list_head`的末尾。

#### 练习2：深入理解不同分页模式的工作原理（思考题）
get_pte()函数（位于`kern/mm/pmm.c`）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
 - get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
 - 目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

1. `get_pte`函数的功能是根据给定的页表基址`pgdir`和虚拟地址`la`，查找或创建对应的页表项，最终返回指向该页表项的指针。

- 通过`PDX1(la)`宏获取虚拟地址`la`对应的一级页表索引，找到对应的一级页表项`pdep1。`
- 检查该一级页表项是否有效。如果该页表项无效就初始化对应的页表项：分配物理页面、设置引用计数、获取物理地址、清零内存区域、构造一级页表项并设置权限。
- 通过一级页表项`pdep1`获取二级页表的地址。
- 通过`PDX0(la)`宏获取虚拟地址`la`对应的二级页表索引，找到对应的二级页表项`pdep0`。
- 检查该一级页表项是否有效。如果该页表项无效就初始化对应的页表项：分配物理页面、设置引用计数、获取物理地址、清零内存区域、构造二级页表项并设置权限。
- 通过二级页表项`pdep0`获取三级页表的地址。
- 通过`PDX0(la)`宏获取虚拟地址`la`对应的三级页表索引，找到并返回最终的目标页表项指针。

这两段代码的查找逻辑是相同的，都是通过访问页表查找页表项，获取下一级页表的地址。

- SV32（两级）
	- 虚拟地址32位
		`+--------+--------+--------+`
		`| VPN[1] | VPN[0] | offset |`
		`+--------+--------+--------+`
		`(10 bits) (10 bits) (12 bits)`
- SV39（三级）
	- 虚拟地址39位
		`+--------+--------+--------+--------+`
		`| VPN[2] | VPN[1] | VPN[0] |  PGOFF |`
		`+--------+--------+--------+--------+`
		`(9 bits) (9 bits) (9 bits) (12 bits)`
- SV48（四级）
	- 虚拟地址48位
		`+--------+--------+--------+--------+--------+`
		`| VPN[3] | VPN[2] | VPN[1] | VPN[0] |  PGOFF |`
		`+--------+--------+--------+--------+--------+`
		`(9 bits) (9 bits) (9 bits) (9 bits) (12 bits)`

sv32，sv39，sv48都是通过通过多级页表进行地址映射。在查找或创建页表项时，都需要遍历各级页表，通过访问页表查找页表项，获取下一级页表的地址。最后一级页表的页表项包含映射到的物理页号。

2. 这种写法更好。因为只有在缺页的时候才会创建页表项，合在一起可以减少代码的冗余，并提高代码的可维护性。

#### 练习3：给未被映射的地址映射上物理页（需要编程）
补充完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制结构所指定的页表，而不是内核的页表。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
 - 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。
 - 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
- 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

设计实现过程：
- `find_vma`函数查找访问出错的虚拟地址`addr`的`vma_struct`结构体
- 通过`vma_struct`的`vm_flags`确定页表项的权限`perm`
- 将地址`addr`按照页面大小`PGSIZE`进行向下对齐。
- `get_pte(mm->pgdir, addr, 1)`函数创建要换入页面的虚拟地址`addr`对应的页表项`ptep`。
	- 如果页表项`ptep`为0，说明该页表项不存在或者无效，因此调用`pgdir_alloc_page`函数来分配一个页面大小的内存并建立地址映射。
	- 如果页表项`ptep`不为`0`，说明该页表项需要被换出。在`swap_init_ok`为真（页面置换相关初始化已完成）的情况下
		- `swap_in(mm,addr,&page)`：将要换出的页面的数据从内存换出到磁盘交换区，将要换入的页面的数据从磁盘换入内存。
        - `page_insert(mm->pgdir,page,addr,perm)`：更新页表，插入要换入的页表项，建立物理地址与虚拟地址的映射。
        - `swap_map_swappable(mm,addr,page,0)`：标记该页面为可交换状态。

#### 练习4：补充完成Clock页替换算法（需要编程）
通过之前的练习，相信大家对FIFO的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 Clock页替换算法（mm/swap_clock.c）。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
 - 比较Clock页替换算法和FIFO算法的不同。

#### 练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）
如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？

#### 扩展练习 Challenge：实现不考虑实现开销和效率的LRU页替换算法（需要编程）
challenge部分不是必做部分，不过在正确最后会酌情加分。需写出有详细的设计、分析和测试的实验报告。完成出色的可获得适当加分。