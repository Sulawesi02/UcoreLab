# OS LAB3 实验报告
## 练习

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点
 
#### 练习0：填写已有实验
本实验依赖实验1/2。请把你做的实验1/2的代码填入本实验中代码中有“LAB1”,“LAB2”的注释相应部分。

#### 练习1：理解基于FIFO的页面替换算法（思考题）
描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？（为了方便同学们完成练习，所以实际上我们的项目代码和实验指导的还是略有不同，例如我们将FIFO页面置换算法头文件的大部分代码放在了`kern/mm/swap_fifo.c`文件中，这点请同学们注意）
 - 至少正确指出10个不同的函数分别做了什么？如果少于10个将酌情给分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响,删去后会导致输出结果不同的函数（例如assert）而不是cprintf这样的函数。如果你选择的函数不能完整地体现”从换入到换出“的过程，比如10个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这10个函数在页面换入时的功能，那么也会扣除一定的分数

1. **_fifo_map_swappable**：将新换入的页面添加到`pra_list_head`链表的末尾，表示该页面最近被换入。
2. **list_add**：宏，用于将页面添加到链表末尾，具体在`_fifo_map_swappable`中调用，实现页面的链表插入操作。
3. **le2page**：宏，用于将链表项转换回页面结构，在处理链表时用于获取页面信息。
4. **_fifo_swap_out_victim**：选择要替换出去的页面，即链表最前面的页面（最早进入的页面），并将其地址设置给`ptr_page`。
5. **list_prev**：宏，用于获取链表中前一个元素，具体在`_fifo_swap_out_victim`中调用，用于找到链表头部的页面。
6. **list_del**：宏，用于从链表中删除一个元素，具体在`_fifo_swap_out_victim`中调用，用于移除被选中替换的页面
7. **swapfs_read**：调用内存和硬盘的I/O接口，读取硬盘中相应的内容到一个内存的物理页，实现换入过程。
8. **swapfs_write**：将被选中替换的页面内容写入到交换文件中，以便后续可以从磁盘中恢复该页面。
9. **get_pte**：获取给定虚拟地址对应的页表项，以便对其进行修改，如标记页面被替换
10. **page_insert**：建立物理地址到虚拟地址的映射，在页面换入时用于更新页表。
11. **swap_out**：负责将页面从物理内存换出到磁盘，调用`_fifo_swap_out_victim`来选择换出页面。
12. **swap_in**：负责将页面从磁盘换入到物理内存，调用`_fifo_map_swappable`来将新页面添加到FIFO链表。
13. **do_pgfault()**：处理页面错误异常。

#### 练习2：深入理解不同分页模式的工作原理（思考题）
get_pte()函数（位于`kern/mm/pmm.c`）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
1. get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
 
    `get_pte`函数的功能是根据给定的页表基址`pgdir`和虚拟地址`la`，查找或创建对应的页表项，最终返回指向该页表项的指针。

- 通过`PDX1(la)`宏获取虚拟地址`la`对应的一级页表索引，找到对应的一级页表项`pdep1。`
- 检查该一级页表项是否有效。如果该页表项无效就初始化对应的页表项：分配物理页面、设置引用计数、获取物理地址、清零内存区域、构造一级页表项并设置权限。
- 通过一级页表项`pdep1`获取二级页表的地址。

- 通过`PDX0(la)`宏获取虚拟地址`la`对应的二级页表索引，找到对应的二级页表项`pdep0`。
- 检查该一级页表项是否有效。如果该页表项无效就初始化对应的页表项：分配物理页面、设置引用计数、获取物理地址、清零内存区域、构造二级页表项并设置权限。
- 通过二级页表项`pdep0`获取三级页表的地址。

- 通过`PDX0(la)`宏获取虚拟地址`la`对应的三级页表索引，找到并返回最终的目标页表项指针。

这两段代码的查找逻辑是相同的，无论是第一级还是最后一级，代码需要检查当前级页表项是否有效（即是否指向下一级页表），如果无效且设置了创建标志，则需要为该级页表分配新的页表项，每一层都可能需要查找和分配，因此代码在形式上非常相似。

- SV32（两级）
	- 虚拟地址32位

		`+---10---+---10---+---12---+`

		`| VPN[1] | VPN[0] | offset |`

		`+--------+--------+--------+`

- SV39（三级）
	- 虚拟地址39位

		`+---9----+---9----+---9----+---12---+`

		`| VPN[2] | VPN[1] | VPN[0] |  PGOFF |`

		`+--------+--------+--------+--------+`

- SV48（四级）
	- 虚拟地址48位

		`+---9----+---9----+---9----+---9----+---12---+`

		`| VPN[3] | VPN[2] | VPN[1] | VPN[0] |  PGOFF |`

		`+--------+--------+--------+--------+--------+`
		
		

sv32，sv39，sv48都是通过通过多级页表进行地址映射。在查找或创建页表项时，都需要遍历各级页表，通过访问页表查找页表项，获取下一级页表的地址。最后一级页表的页表项包含映射到的物理页号。

2. 目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

    这种写法更好。因为只有在缺页的时候才会创建页表项，写在一起可以减少函数调用的开销，并且在多数情况下，查找和分配是连续的操作，合并可以简化代码逻辑。

#### 练习3：给未被映射的地址映射上物理页（需要编程）
补充完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制结构所指定的页表，而不是内核的页表。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
- 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。
- 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
  - 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

1. 设计实现过程：

- `find_vma`函数查找访问出错的虚拟地址`addr`的`vma_struct`结构体
- 通过`vma_struct`的`vm_flags`确定页表项的权限`perm`
- 将地址`addr`按照页面大小`PGSIZE`进行向下对齐。
- `get_pte(mm->pgdir, addr, 1)`函数创建要换入页面的虚拟地址`addr`对应的页表项`ptep`。
	- 如果页表项`ptep`为0，说明该页表项不存在或者无效，因此调用`pgdir_alloc_page`函数来分配一个页面大小的内存并建立地址映射。
	- 如果页表项`ptep`不为`0`，说明该页表项需要被换出。在`swap_init_ok`为真（页面置换相关初始化已完成）的情况下
		- `swap_in(mm,addr,&page)`：将要换出的页面的数据从内存换出到磁盘交换区，将要换入的页面的数据从磁盘换入内存。
        - `page_insert(mm->pgdir,page,addr,perm)`：更新页表，插入要换入的页表项，建立物理地址与虚拟地址的映射。
        - `swap_map_swappable(mm,addr,page,0)`：标记该页面为可交换状态。
2. 页目录项和页表项中组成部分对ucore实现页替换算法的潜在用处：

页表项中的PTE_D 表示内存页是否被修改过， PTE_A 表示内存页是否被访问过。

- PTE_A用于实现时钟（Clock）页替换算法。
- PTE_D和PTE_A用于实现改进的时钟（Enhanced Clock）页替换算法。

```c
// Sv39 page table entry:
// +----26---+----9---+----9---+---2----+-------8-------+
// |  PPN[2] | PPN[1] | PPN[0] |Reserved|D|A|G|U|X|W|R|V|
// +---------+----+---+--------+--------+---------------+
```

- 时钟（Clock）页替换算法：是 LRU 算法的一种近似实现。时钟页替换算法把各个页面组织成环形链表的形式，类似于一个钟的表面。然后把一个指针（简称当前指针）指向最老的那个页面，即最先进来的那个页面。另外，**时钟算法需要在页表项（PTE）中设置了一位访问位来表示此页表项对应的页当前是否被访问过**。当该页被访问时，CPU 中的 MMU 硬件将把访问位置“1”。当操作系统需要淘汰页时，对当前指针指向的页所对应的页表项进行查询，如果访问位为“0”，则淘汰该页，如果该页被写过，则还要把它换出到硬盘上；如果访问位为“1”，则将该页表项的此位置“0”，继续访问下一个页。该算法近似地体现了 LRU 的思想，且易于实现，开销少，需要硬件支持来设置访问位。时钟页替换算法在本质上与 FIFO 算法是类似的，不同之处是在时钟页替换算法中跳过了访问位为 1 的页。
- 改进的时钟（Enhanced Clock）页替换算法：在时钟置换算法中，淘汰一个页面时只考虑了页面是否被访问过，但在实际情况中，还应考虑被淘汰的页面是否被修改过。因为淘汰修改过的页面还需要写回硬盘，使得其置换代价大于未修改过的页面，所以优先淘汰没有修改的页，减少磁盘操作次数。改进的时钟置换算法除了考虑页面的访问情况，还需考虑页面的修改情况。即该算法不但希望淘汰的页面是最近未使用的页，而且还希望被淘汰的页是在主存驻留期间其页面内容未被修改过的。**这需要为每一页的对应页表项内容中增加一位引用位和一位修改位。**当该页被访问时，CPU 中的 MMU 硬件将把访问位置“1”。当该页被“写”时，CPU 中的 MMU 硬件将把修改位置“1”。这样这两位就存在四种可能的组合情况：（0，0）表示最近未被引用也未被修改，首先选择此页淘汰；（0，1）最近未被使用，但被修改，其次选择；（1，0）最近使用而未修改，再次选择；（1，1）最近使用且修改，最后选择。该算法与时钟算法相比，可进一步减少磁盘的 I/O 操作次数，但为了查找到一个尽可能适合淘汰的页面，可能需要经过多次扫描，增加了算法本身的执行开销。

3. 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，硬件要做哪些事情？

- 将页访问异常的错误码压入内核栈的栈顶。
- 将导致页访问异常的虚拟地址记录在CR2寄存器中。
- 保存状态寄存器PSW（程序状态字）及断点等信息

之后触发 Page Fault 异常，进入do_pgdefault函数处理。

4. 数据结构Page的全局变量的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

page结构如下所示

```
struct Page {
    int ref;                        // page frame's reference counter
    uint_t flags;                 // array of flags that describe the status of the page frame
    uint_t visited;
    unsigned int property;          // the num of free block, used in first fit pm manager
    list_entry_t page_link;         // free list link
    list_entry_t pra_page_link;     // used for pra (page replace algorithm)
    uintptr_t pra_vaddr;            // used for pra (page replace algorithm)
};
```

页目录项和页表项结构如下所示

```
// Sv39 page table entry:
// +----26---+----9---+----9---+---2----+-------8-------+
// |  PPN[2] | PPN[1] | PPN[0] |Reserved|D|A|G|U|X|W|R|V|
// +---------+----+---+--------+--------+---------------+
```

对应关系为visited和PTE_A

- `struct Page` 中的 `visited` 字段用于跟踪页面的访问历史.
- 在页表项（PTE）中，`A`（访问位）标志位用于表示页面自上次清零以来是否被访问过。

#### 练习4：补充完成Clock页替换算法（需要编程）
通过之前的练习，相信大家对FIFO的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 Clock页替换算法（mm/swap_clock.c）。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
 - 比较Clock页替换算法和FIFO算法的不同。

设计实现过程：
1. `_clock_init_mm`函数：初始化
- 通过`list_init`函数将`pra_list_head`初始化为空链表。
- 初始化`curr_ptr`指向`pra_list_head`，表示当前页面替换位置为链表头。
- 将`mm_struct`结构体中的`sm_priv`成员指向`pra_list_head`，这样就建立起了从内存管理结构体到页面链表的关联，方便后续在涉及页面置换等操作时能够通过`mm_struct`访问到该链表。

2. `_clock_map_swappable`函数：更新可交换页面链表
- 获取指向链表头节点`pra_list_head`的指针`head`。
- 获取要插入页面的链表节点指针`entry`。
- 通过`list_add_before`函数将页面`page`插入到页面链表`pra_list_head`的末尾。
- 更新`curr_ptr`指向页面`page`
- 将页面的`visited`标志置为`1`，表示该页面已被访问过。

3. `_clock_swap_out_victim`函数：选择要换出的页面
- 在循环中
	- 将`curr_ptr`指向链表头的下一个页面。
	- 如果 `curr_ptr` 不是链表的头部
		- 获取当前页面对应的 `Page` 结构指针。
		- 如果当前页面未被访问过，则调用`cprintf("curr_ptr %p\n",curr_ptr);`，则将页面指针赋值给`ptr_page`作为要换出的页面，将该页面从页面链表中删除，输出`curr_ptr`的值。
		- 如果当前页面已经被访问过（`page->visited` 为真），则将`visited`标志置为`0`。
	- 如果 `curr_ptr` 是链表的头部，则将 `ptr_page` 设为 `NULL`。


Clock页替换算法和FIFO算法的不同：
- Clock算法：每次添加新页面时会将页面添加到链表尾部。为每个页面设置了一个访问标记，每次换出页面时都会遍历查找访问标记为0的页面。
    
- FIFO算法：将可交换页面链表是一个队列，每次添加新页面会将页面添加到链表头部（队列的末尾）。每次换出页面时将队头页面换出。
#### 练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）
如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？

- 好处：
	- 映射效率高，只需一次查找就能直接定位
	- 页表占用空间小。分级页表需要维护多个级别的页表结构，每一级页表都需要一定的内存空间，而 “一个大页” 的映射方式只需要一个页表项来映射整个大页。
	- 管理简单。分级页表的管理涉及到多个级别的页表维护，包括页表项的创建、更新、删除等操作，而 “一个大页” 的映射方式只需要管理一个页表项。

- 坏处：
	- 一个程序通常含有`.text`段、`.rodata` 段、`.data` 段、`.bss`段，如果使用一个大页进行映射时，它们都拥有相同的权限，会带来安全隐患。例如修改内核 `.text` 段的代码，通过标志位 `W=1` 的页表项完成映射。
	- 内存浪费。如果一个程序只需要使用大页中的一小部分内存，那么其余未使用的部分也会被分配并占用物理内存。
	- 上下文切换，需要更新页表中的映射关系，将产生额外的开销和延迟；
#### 扩展练习 Challenge：实现不考虑实现开销和效率的LRU页替换算法（需要编程）
challenge部分不是必做部分，不过在正确最后会酌情加分。需写出有详细的设计、分析和测试的实验报告。完成出色的可获得适当加分。

